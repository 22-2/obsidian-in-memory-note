import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { copyFileSync, existsSync, mkdirSync, renameSync, statSync } from "fs";
import dotenv from "dotenv";
import path from "path";
import fs from "fs/promises";

import manifest from "./manifest.json";
dotenv.config();

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

type CopyPluginOptions = {
	opts: {
		src: string[];
		dest: string;
	}[];
};

const copyPlugin = ({ opts }: CopyPluginOptions): esbuild.Plugin => ({
	name: "copy-plugin",
	setup(build) {
		build.onEnd(async (result) => {
			if (result.errors.length > 0) {
				console.warn("[CopyPlugin] Build failed. Skipping file copy.");
				return;
			}

			console.log("[CopyPlugin] Starting file copy process...");

			for (const { src, dest } of opts) {
				if (!dest) {
					console.error(`[CopyPlugin] Destination path is required.`);
					continue;
				}

				try {
					// 1. まず、コピー先のディレクトリ（dest）が存在するか確認し、なければ再帰的に作成する
					await fs.mkdir(dest, { recursive: true });

					for (const srcPath of src) {
						// 2. 堅牢な方法でファイル名を取得する
						const fileName = path.basename(srcPath);
						const destPath = path.join(dest, fileName);

						try {
							// 3. ソースファイルが存在するか確認
							await fs.access(srcPath);

							// 4. ファイルをコピーする
							await fs.copyFile(srcPath, destPath);
							console.log(
								`[CopyPlugin] Copied: ${srcPath} -> ${destPath}`
							);
						} catch (e) {
							if (
								e instanceof Error &&
								"code" in e &&
								e.code === "ENOENT"
							) {
								console.warn(
									`[CopyPlugin] Warning: Source file not found: ${srcPath}. Skipping.`
								);
							} else {
								console.error(
									`[CopyPlugin] Failed to copy ${srcPath}:`,
									e
								);
							}
						}
					}
				} catch (e) {
					// 主にfs.mkdirが失敗した場合などの致命的なエラーをキャッチ
					console.error(
						`[CopyPlugin] Failed processing destination group for '${dest}':`,
						e
					);
				}
			}
			console.log("[CopyPlugin] File copy process finished.");
		});
	},
});

const mode = process.argv[2];
const prod = mode === "production";
const e2e = mode === "e2e";
const e2eDev = mode === "e2e-dev";

const copyOpts = {
	opts: [
		{
			src: ["./styles.css", "./manifest.json", "./main.js"],
			dest: "./dist",
		},
	],
};

if (process.env.OBSIDIAN_SANDBOX_PATH)
	copyOpts.opts.push({
		src: ["./dist/styles.css", "./dist/manifest.json", "./dist/main.js"],
		dest:
			path.join(
				process.env.OBSIDIAN_SANDBOX_PATH!,
				".obsidian",
				"plugins",
				manifest.id
			) || "",
	});

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	define: {
		"process.env.NODE_ENV": prod ? '"production"' : '"development"',
		"process.env.BUILT_AT": JSON.stringify(
			new Intl.DateTimeFormat("ja-JP", {
				year: "numeric",
				month: "2-digit",
				day: "2-digit",
				weekday: "long",

				hour: "2-digit",
				minute: "2-digit",
				second: "2-digit",
				fractionalSecondDigits: 2,

				timeZone: "Asia/Tokyo",
				timeZoneName: "long",
			})
				.format(new Date())
				.replace(/[\\/:*?"<>|\s.]/g, "-")
		),
	},
	plugins: e2eDev || e2e ? [copyPlugin(copyOpts)] : [],
	entryPoints: ["src/main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins,
	],
	format: "cjs",
	target: "esnext",
	logLevel: "info",
	minify: prod,
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outfile: "main.js",
});

if (prod || e2e) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
